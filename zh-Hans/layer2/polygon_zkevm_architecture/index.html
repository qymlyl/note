<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-layer2/polygon_zkevm_architecture" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Polygon整体架构和主要流程 | qymlyl note</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://qymlyl.github.io/note/zh-Hans/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://qymlyl.github.io/note/zh-Hans/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://qymlyl.github.io/note/zh-Hans/layer2/polygon_zkevm_architecture"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Polygon整体架构和主要流程 | qymlyl note"><meta data-rh="true" name="description" content="概述"><meta data-rh="true" property="og:description" content="概述"><link data-rh="true" rel="icon" href="/note/zh-Hans/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://qymlyl.github.io/note/zh-Hans/layer2/polygon_zkevm_architecture"><link data-rh="true" rel="alternate" href="https://qymlyl.github.io/note/layer2/polygon_zkevm_architecture" hreflang="en"><link data-rh="true" rel="alternate" href="https://qymlyl.github.io/note/zh-Hans/layer2/polygon_zkevm_architecture" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://qymlyl.github.io/note/layer2/polygon_zkevm_architecture" hreflang="x-default"><link rel="stylesheet" href="/note/zh-Hans/assets/css/styles.75314c4a.css">
<link rel="preload" href="/note/zh-Hans/assets/js/runtime~main.4c2e441e.js" as="script">
<link rel="preload" href="/note/zh-Hans/assets/js/main.7f2867a2.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><a class="navbar__brand" href="/note/zh-Hans/"><div class="navbar__logo"><img src="/note/zh-Hans/img/logo.svg" alt="qymlyl note Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/note/zh-Hans/img/logo.svg" alt="qymlyl note Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">qymlyl note</b></a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/note/zh-Hans/home">首页</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/note/zh-Hans/tools/ubuntu-usage">工具</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/note/zh-Hans/ethereum/whitepaper">以太坊</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/note/zh-Hans/layer2/scroll_architecture">Layer2学习</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/note/zh-Hans/layer2/scroll_architecture">Scroll整体架构和主要流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/note/zh-Hans/layer2/polygon_zkevm_architecture">Polygon整体架构和主要流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/note/zh-Hans/layer2/ethereum_storage">EthStorage</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/note/zh-Hans/zkp_study/zkp_history">zkp学习</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/note/zh-Hans/risc-v/ubuntu-install-riscv-gnu-toolchain">risc-v</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/note/zh-Hans/rust/little-tools">Rust</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/note/zh-Hans/rCore-Tutorial-Book学习/ch1-setup-os-devel-env">rCore-Tutorial-Book学习</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/note/zh-Hans/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Layer2学习</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Polygon整体架构和主要流程</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>Polygon zkevm 架构调研</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="概述">概述<a href="#概述" class="hash-link" aria-label="概述的直接链接" title="概述的直接链接">​</a></h2><p>官网：<a href="https://docs.polygon.technology/zkEVM/architecture/" target="_blank" rel="noopener noreferrer">https://docs.polygon.technology/zkEVM/architecture/</a></p><p>Hermes1.0是以太坊第一个去中心化的zkRollup，于2021年3月上线，可实现2000tps，足以满足ETH及ERC-20 token的转账合约，Hermes1.0并不是与EVM完全兼容的。</p><p>Hermes2.0的定位是zkEVM，相较于Hermes 1.0， Hermes 2.0最主要的功能就是提供智能合约的支持，Hermez 2.0 zkEVM与以太坊主网EVMs兼容。可将以太坊主网的智能合约部署在Polygon zkEVM中，可共用以太坊现有的开发工具和套件。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="polygon-zkevm整体架构">Polygon zkEVM整体架构<a href="#polygon-zkevm整体架构" class="hash-link" aria-label="Polygon zkEVM整体架构的直接链接" title="Polygon zkEVM整体架构的直接链接">​</a></h2><p>官方架构图：</p><p><img loading="lazy" src="/note/zh-Hans/assets/images/polygon_zkevm_architecture-53f12bf44ca54118789b5befd6d61402.png" width="874" height="708" class="img_ev3q"></p><p>(感觉这个架构图描述不是特别清晰，只是知道有哪些组件，组件之间的层次并不是很清晰)。</p><p>Polygon zkEVM中包含的主要组件有：</p><ul><li>共识合约（POE共识，PolygonZkEVM.sol）</li><li>zkNode:<ul><li>同步器（Synchronizer）</li><li>排序器（Sequencers）</li><li>聚合器（Aggregators）</li><li>RPC</li></ul></li><li>zk验证器（zkProver）</li><li>zkEVM Bridge（跨链桥）</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="zknode">zkNode<a href="#zknode" class="hash-link" aria-label="zkNode的直接链接" title="zkNode的直接链接">​</a></h2><p>zkNode是运行zkEvm节点所需要的软件，它是同步并了解Polygon zkEVM状态所需要的客户端。</p><p>改变L2状态及最终结果确认的主要参与者是：受信任的Sequencer和受信任的Aggregator。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="zknode架构">zkNode架构<a href="#zknode架构" class="hash-link" aria-label="zkNode架构的直接链接" title="zkNode架构的直接链接">​</a></h3><p>zkNode官方架构（来自：<a href="https://docs.polygon.technology/zkEVM/architecture/zknode/%E5%92%8Chttps://github.com/0xPolygonHermez/zkevm-node%EF%BC%89%EF%BC%9A" target="_blank" rel="noopener noreferrer">https://docs.polygon.technology/zkEVM/architecture/zknode/和https://github.com/0xPolygonHermez/zkevm-node）：</a></p><p><img loading="lazy" src="/note/zh-Hans/assets/images/polygon_zkevm_zknode-ea43a42d8c192e436163cd147433b603.png" width="1800" height="1000" class="img_ev3q"></p><p><img loading="lazy" alt="polygon_zknode_architecture_02" src="/note/zh-Hans/assets/images/polygon_zknode_architecture_02-cfde953e5f0fbecd97c83b1792f0c64c.png" width="547" height="858" class="img_ev3q"></p><p>（上图逻辑看着不是很清晰，看完还是有点不太理解流程执行顺序是什么）。</p><p>zkEVM组件列表如下：</p><ul><li>Pool DB：存储用户提交的交易，交易被保存在Pool中，等待Sequencer将交易打包成batch。</li><li>Sequencer：是一个节点，负责从PoolDb中获取交易，检查交易是否有效，然后将有效交易打包成batch。Sequencer将所有的batch提交给L1，由L1对batch进行排序。这样，已排序的batch旧包含在了L1的状态中。</li><li>Aggregator：是另外一个节点，从L1中获取到batch，并为batch生成证明，然后提交到L1进行有效性验证。</li><li>Prover：用于为batch计算ZK证明，并将多个batch的证明聚合成一个证明，作为有效性证明进行发布。</li><li>Synchronizer：通过Etherman从以太坊获取数据来更新状态数据库。</li><li>Etherman是一个低级的组件，它实现了与L1网络和智能合约交互的方法。</li><li>State DB：用于持久化存储状态数据（不是Merkle树）的数据库。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="zknode中的角色">zkNode中的角色<a href="#zknode中的角色" class="hash-link" aria-label="zkNode中的角色的直接链接" title="zkNode中的角色的直接链接">​</a></h3><p>来自：<a href="https://docs.polygon.technology/zkEVM/architecture/zknode/" target="_blank" rel="noopener noreferrer">https://docs.polygon.technology/zkEVM/architecture/zknode/</a></p><p>zkNode软件支持多种角色，每个角色需要不同的服务才能进行工作，大多数的服务可以在不同的实例中运行，但是JsonRpc可以在多个实例中运行。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="rpc-endpoints">RPC endpoints<a href="#rpc-endpoints" class="hash-link" aria-label="RPC endpoints的直接链接" title="RPC endpoints的直接链接">​</a></h4><p>任何用户都可以作为 RPC 节点参与此角色。</p><p>所需的服务和组件：</p><ul><li>JSON RPC：可以在单独的实例上运行，并且可以有多个实例。</li><li>同步器：可以在单独的实例上运行的单个实例。</li><li>Executor &amp; Merkletree：可以在单独的实例上运行的服务。</li><li>状态数据库：可以在单独的实例上运行的 Postgres SQL。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="trusted-sequencer">Trusted sequencer<a href="#trusted-sequencer" class="hash-link" aria-label="Trusted sequencer的直接链接" title="Trusted sequencer的直接链接">​</a></h4><p>此角色只能由单个实体执行。这是在智能合约中强制执行的，因为可信排序器的相关方法只能由特定私钥的所有者执行（这个还有点不太懂）。</p><p>所需的服务和组件：</p><ul><li>JSON RPC：可以在单独的实例上运行，并且可以有多个实例。</li><li>Sequencer和Synchronizer：需要将它们一起运行的单个实例。</li><li>Executor &amp; Merkletree：可以在单独的实例上运行的服务。</li><li>Pool DB：可以在单独的实例上运行的 Postgres SQL。</li><li>State DB：可以在单独的实例上运行的 Postgres SQL。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="aggregator">Aggregator<a href="#aggregator" class="hash-link" aria-label="Aggregator的直接链接" title="Aggregator的直接链接">​</a></h4><p>这个角色可以由任何人来扮演。</p><p>所需的服务和组件：</p><ul><li>Synchronizer：可以在单独的实例上运行的单个实例。</li><li>Executor &amp; Merkletree：可以在单独的实例上运行的服务。</li><li>State DB：可以在单独的实例上运行的 Postgres SQL。</li><li>Aggregator：可以在单独的实例上运行的单个实例。</li><li>Prover：可以在单独的实例上运行的单个实例。</li><li>Executor：可以在单独的实例上运行的单个实例。</li></ul><p>建议证明者在单独的实例上运行，因为它有重要的硬件要求。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="疑问">疑问<a href="#疑问" class="hash-link" aria-label="疑问的直接链接" title="疑问的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="aggregator怎么获取batches">Aggregator怎么获取batches<a href="#aggregator怎么获取batches" class="hash-link" aria-label="Aggregator怎么获取batches的直接链接" title="Aggregator怎么获取batches的直接链接">​</a></h4><p>不理解的问题，Aggregator怎么获取batches的？是从State直接获取的数据，还是直接从L1获取？</p><p>上面的图中Aggregator是直接从State中获取的Prover所需要的数据的，但是官方有一张图，如下（来自：<a href="https://docs.polygon.technology/zkEVM/architecture/protocol/state-management/#trustless-l2-state-management%EF%BC%89%EF%BC%9A" target="_blank" rel="noopener noreferrer">https://docs.polygon.technology/zkEVM/architecture/protocol/state-management/#trustless-l2-state-management）：</a></p><p><img loading="lazy" alt="polygon_01L2-overview-l2-state-management" src="/note/zh-Hans/assets/images/polygon_01L2-overview-l2-state-management-351beb2cceeed72c2e107320699c7fcf.png" width="1800" height="1000" class="img_ev3q"></p><p>Aggregator从L1的PolygonZkEVM合约中直接获取batches, 然后利用Prover做证明的。</p><p>所以Aggregator怎么获取batches的？是从State直接获取的数据，还是直接从L1获取？</p><p>可能是这样的Aggregator有自己的Synchronizer，也有自己的State，Aggregator的Synchronizer从L1拉取batches，然后村存储在Aggregator的Statedb中，Aggregator在计算ZK Proof时，就会从State请求获取prover所需要的数据。</p><p>因为Aggregator需要Synchronizer和StateDB，参考zkNode中的角色。</p><p>那么Synchronizer和State是Sequencer和Aggregator共用的吗？？</p><p>这个不太清楚，zkNode中的角色中介绍有，Aggregator需要Synchronizer和StateDB， Sequencery要有自己的ynchronizer和StateDB。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="交易流程">交易流程<a href="#交易流程" class="hash-link" aria-label="交易流程的直接链接" title="交易流程的直接链接">​</a></h3><p>根据自己的理解画的图(State和StateDB这一块还不是很清楚)， 整体通过Synchronizer来将各个模块进行解耦合。</p><p><img loading="lazy" alt="polygon_zkevm_main_process_01" src="/note/zh-Hans/assets/images/polygon_zkevm_main_process_01-730ad97a8fe6259d17d43705e165b16f.png" width="4204" height="2012" class="img_ev3q"></p><p>大概流程：</p><p><img loading="lazy" alt="polygon_01L2-overview-l2-state-management" src="/note/zh-Hans/assets/images/polygon_01L2-overview-l2-state-management-351beb2cceeed72c2e107320699c7fcf.png" width="1800" height="1000" class="img_ev3q"></p><p>主要分为三个步骤：</p><ol><li>Sequencer将多个用户的交易打包成Batch提交到L1的合约上（Data Avaliability）。</li><li>Prover为每笔交易生成有效性证明（validity proof）,并将多个交易的有效性证明聚合成一个有效性证明。</li><li>Aggregator提交聚合了多个交易的有效性证明（validity proof）到L1的合约上。</li></ol><h4 class="anchor anchorWithStickyNavbar_LWe7" id="sequencer将交易提交到l1">Sequencer将交易提交到L1<a href="#sequencer将交易提交到l1" class="hash-link" aria-label="Sequencer将交易提交到L1的直接链接" title="Sequencer将交易提交到L1的直接链接">​</a></h4><ol><li><p>用户将交易发送给Sequencer，Sequencer会在本地按照收到交易的快慢顺序进行处理(FRFS)，当Sequencer在本地将交易执行成功之后，如果用户相信Sequencer是诚实的，那么他就可以认为这个时候的交易已经达成finality。</p></li><li><p>Sequencer会将多笔交易打包进一个Batch里面(目前是一个Batch里面只包含一个交易)，然后收集到多个Batches之后，通过L1上的<code>PolygonZkEVM.sol</code>的<code>sequenceBatch()</code>函数将多个Batch一起发送到L1交易的calldata上。</p></li><li><p>当<code>PolygonZKEVM.sol</code>收到Sequencer提供的Batches后，会依次在合约内计算每个Batch的哈希，然后在后一个Batch里面记录前一个Batch的哈希（和Block类似）,如下图。</p></li><li><p>Batch里面的交易也是确定的，所以当Batch的顺序确认之后，我们认为所有被包含在Batch提交到L1的PolygonZkEVM合约的<strong>交易的顺序都是确认</strong>的。</p><p><img loading="lazy" alt="polygon_sequencing_batches" src="/note/zh-Hans/assets/images/polygon_sequencing_batches-1dab1f1078cda87b6cf43b333aedf43e.png" width="1800" height="1000" class="img_ev3q"></p></li></ol><p><img loading="lazy" src="/note/zh-Hans/assets/images/polygon_batch_chain_acc_hash-fbdfb56d416c2139a550290c5d4f1e20.png" width="1800" height="1000" class="img_ev3q"></p><p>此阶段，将L1充当Rollup DA层和完成交易排序。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="aggregator生成validity-proof">Aggregator生成validity proof<a href="#aggregator生成validity-proof" class="hash-link" aria-label="Aggregator生成validity proof的直接链接" title="Aggregator生成validity proof的直接链接">​</a></h4><ol><li>当Aggregator监听到L1的<code>PolygonZkEVM.sol</code>合约中已经有新的Batch被成功提交后，它会把这些Batch同步到自己的节点里，然后给zkProver发送这些交易。</li><li>zkProver接收到这些交易之后会并行的为每笔交易生成有效性证明(validity proof)，然后再将多个Batch包含的交易的validity proof再聚合成一个有效性证明(validity proof)</li><li>zkProver将聚合多个交易的validity proof发送给Aggregator</li></ol><p><img loading="lazy" alt="polygon_zkProv_arch" src="/note/zh-Hans/assets/images/polygon_zkProv_arch-431fc1b9485b1ee5f6d038a5f7518865.png" width="1230" height="700" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="aggregator提交聚合证明到l1">Aggregator提交聚合证明到L1<a href="#aggregator提交聚合证明到l1" class="hash-link" aria-label="Aggregator提交聚合证明到L1的直接链接" title="Aggregator提交聚合证明到L1的直接链接">​</a></h4><ol><li>Aggregator会讲聚合后到有效性证明(validity proof)以及对应的这些Batch执行后的状态一起提交到L1的<code>PolygonZkevm.sol</code>合约内（调用<code>trustedVerifyBatches </code>方法）。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="三种finality">三种Finality<a href="#三种finality" class="hash-link" aria-label="三种Finality的直接链接" title="三种Finality的直接链接">​</a></h3><p>可以认为目前整个网络存在三种不同程度的Finality，给它们命名成Sequencer Finality, DA Finality和Verified Finality。</p><ol><li><p>Sequecer Finality，也将这种Finality称为Soft Finality,Polygon中也叫做Sequenecer Finality更为合适，因为这是Single Sequencer 给的状态承诺。</p><p>Sequencer接受到用户交易之后，执行后给出的状态，这是最不安全的状态；但是在目前官方Single Sequencer的场景下，却可以在保证安全的同时带来极致的用户体验。在目前Single Sequencer的Rollup网络中，基本上都可以体验到即时确认的快乐。不过，Single Sequencer最大的风险就是Sequencer宕机，这会导致整个L2网络基本瘫痪，不过由于DA层是位于以太坊上的，依然可以在之后部分恢复L2网络宕机前的状态；不过那部分来不及发送到L1的L2交易将无法被恢复。</p></li><li><p>DA Finality，代表这些交易已经被提交到L1的DA层合约上，此时交易顺序也被确定了。</p><p>Trusted Sequencer已经调用<code>sequenceBatch</code> 将交易发送到L1上，在这种情况下，交易已经被DA层包含；在Polygon的设计中, 由于Single Trusted Sequencer的原因，所以可以确保上传到L1合约上进行DA的交易都是有效交易。我们可以认为当一笔交易被Trusted Sequencer 上传到L1合约中的时候, 这个时候它已经被rollup网络承认了，并且在之后Aggregator会提供validity proof让这笔交易真正无法被revert(除非L1 reorg)。</p></li><li><p>Verified Finality，指的是这笔交易已经通过validity proof的验证了，属于真正的Finality，也叫做Hard Finality。</p><p>当Aggregator为一批上传到DA层的交易提供的validity proof被合约验证通过的时候，这个时候我们认为这些交易已经无法被revert了(除非L1 reorg)。目前提交到DA层的交易到验证validity proof的通过的时间是30分钟，同时Aggregator也可以通过提供validity proof从而获得足够的Matic报酬。</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="跨链">跨链<a href="#跨链" class="hash-link" aria-label="跨链的直接链接" title="跨链的直接链接">​</a></h2><p>Polygon zkEVM在L1和L2上分别维护了一颗Exit Tree,  名字分别为L1 Exit Merkel tree和L2 Exit Merkel tree。为了更好的管理这两棵树，Polygon zkEVM把这两棵树结合在了一起，如下：</p><p><img loading="lazy" alt="img" src="/note/zh-Hans/assets/images/polygon_global_exit_tree_root-e6668952ded0fd602c9df5a28302136d.png" width="898" height="359" class="img_ev3q"></p><p>即把 L1 Exit Tree Root 作为 Global Exit Tree 的左叶子节点，把 L2 Exit Tree Root 作为 Global Exit Tree 的右叶子节点。不过需要注意这里 L1 Tree Root 和 L2 Tree Root 是 Sparse Merkle Tree(SMT),而 Global Exit Tree 是 Binary Merkle Tree。</p><p>在 Polygon zkEVM 的合约设计中，还是尽可能的将 Bridge 和 Consensus 合约尽可能的解耦。目前其在 L1 部署的合约主要分为 3 个（3个合约是独立的没有继承关系），如下图所示:</p><p><img loading="lazy" alt="img" src="/note/zh-Hans/assets/images/polygon_bridge_2_contract-370bc8ece86ba7a68794eff60e2ea11d.png" width="898" height="334" class="img_ev3q"></p><ul><li>PolygonZkEVMBridge.sol：跨链桥合约，当用户在源链发起链交易时，会调用<code>bridgeAsset()</code>方法，或者在目标链调用该合约的<code>claimAsset()</code>方法获得对应链的资产。</li><li>PolygonZkEVMGlobalExitRoot.sol: 用于管理ExitTree的合约，PolygonZkEVMBridge.sol和PolygonZkEVM.sol都会调用PolygonZkEVMGlobalExitRoot.sol来更新Global Exit Tree Root。</li><li>PolygonZkEVM.sol：共识合约，主要用于上传Batch和验证validity proof</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="l1---l2">L1---&gt;L2<a href="#l1---l2" class="hash-link" aria-label="L1---&gt;L2的直接链接" title="L1---&gt;L2的直接链接">​</a></h3><p>L1到L2的跨链流程对应上图的橙色表示。</p><ol><li>用户先调用部署在L1上的PolygonZkEVMBridge.sol的<code>bridgeAsset()</code>方法，这个方法会将当前跨链的metadata添加到L1 Exit Tree中并更新<code>L1 Exit Tree Root</code>。</li><li>然后调用更新PolygonZkEVMGlobalExitRoot.sol合约中的<code>Global Exit Tree Root</code>。</li><li>L2有一个Global Exit Root Manager的角色监听发现L1的L1 Tree Root和Global Exit Tree Root都更新之后，会把这个新的Global Exit Tree Root更新到L2的zkEVM中。</li><li>此时用户就可以在L2的PolygonZkEVMBridge.sol合约中调用<code>claimAsset()</code>方法进行取款(合约会验证用户提供的Merkel Path是否和当前的Tree Root匹配)。</li><li>将会在下次调用PolygonZkEVM.sol时的<code>sequenceBatch()</code>方法的时候，每一个Batch都需要一个有效的<code>Global Exit Tree Root</code>或者一个<code>Empty Root</code>，当这个<code>Global Exit Tree Root</code>结合后续提交的<code>validity proof</code>被验证通过的时候(证明Global Exit Root Manager同步到L2的<code>Global Exit Tree Root</code>是正确的)，这个时候才可以认为整个跨链流程已完结。</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="poeproof-0f-efficiency">POE(Proof-0f-Efficiency)<a href="#poeproof-0f-efficiency" class="hash-link" aria-label="POE(Proof-0f-Efficiency)的直接链接" title="POE(Proof-0f-Efficiency)的直接链接">​</a></h2><h4 class="anchor anchorWithStickyNavbar_LWe7" id="概述-1">概述<a href="#概述-1" class="hash-link" aria-label="概述的直接链接" title="概述的直接链接">​</a></h4><p>主要用于对交易进行排序，Sequencer可能有多个，每一个Sequencer将交易的batch提交的PoE合约，合约对交易进行排序，即当前的Batch中会包含上一个Batch的hash(类似于L1的block)，这样的Batch的顺序就被确定了，Batch的顺序确定也意味着交易的顺序被确定。</p><p>Hermez是被设计为去中心化的，不同于Hermez 1.0中使用的PoD(Proof-of-Donation)共识算法，Hermez 2.0采用的是PoE(Proof-of-Effciency)共识。</p><p>PoE共识算法主要分为2步，可由不同的参与者完成：</p><ol><li>第一步的参与者为Sequencer，Sequencer负责将L2的交易打包为batches并添加到L1的PoE智能合约中，合约中对batches进行排序，Sequencer是存在多个的，任何人都可以成为Sequencer。</li><li>第二步的参与者为Aggregator，Aggregator之间是竞争的，负责检查transaction batches的有效性，并提供validity proofs，Aggregator是多个，任何人都可以参与。</li></ol><p>PoE智能合约中有2个基本接口：</p><ol><li><code>sendBatch</code>：用于接收Sequencer的batches，进行batch排序</li><li><code>validateBatch</code>：用于接收Aggregator的validity proof，进行validate batches</li></ol><p><img loading="lazy" alt="polygon_poe_process" src="/note/zh-Hans/assets/images/polygon_poe_process-f679be1440994b28708e51f3c463f2a1.png" width="1252" height="685" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="poe共识">PoE共识<a href="#poe共识" class="hash-link" aria-label="PoE共识的直接链接" title="PoE共识的直接链接">​</a></h4><h2 class="anchor anchorWithStickyNavbar_LWe7" id="激励机制">激励机制<a href="#激励机制" class="hash-link" aria-label="激励机制的直接链接" title="激励机制的直接链接">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="疑问-1">疑问：<a href="#疑问-1" class="hash-link" aria-label="疑问：的直接链接" title="疑问：的直接链接">​</a></h2><p>Single Sequencer和Trusted Sequencer？</p><p>StateDB?</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考">参考<a href="#参考" class="hash-link" aria-label="参考的直接链接" title="参考的直接链接">​</a></h2><p>官网：<a href="https://docs.polygon.technology/zkEVM/architecture/" target="_blank" rel="noopener noreferrer">https://docs.polygon.technology/zkEVM/architecture/</a></p><p>详解 Polygon zkEVM 的整体架构和交易执行流程: <a href="https://learnblockchain.cn/article/5636%EF%BC%8C" target="_blank" rel="noopener noreferrer">https://learnblockchain.cn/article/5636，</a> <a href="https://learnblockchain.cn/article/5647" target="_blank" rel="noopener noreferrer">https://learnblockchain.cn/article/5647</a></p><p>技术详解 Polygon zkEVM Bridge 和 Sequencer 框架: <a href="https://learnblockchain.cn/article/5487" target="_blank" rel="noopener noreferrer">https://learnblockchain.cn/article/5487</a></p><p>视频：<a href="https://www.bilibili.com/video/BV1c24y1K7Kr/?spm_id_from=333.999.0.0&amp;vd_source=fe3786828d0a7b2978993fb28bb81b78" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1c24y1K7Kr/?spm_id_from=333.999.0.0&amp;vd_source=fe3786828d0a7b2978993fb28bb81b78</a></p><p>Polygon zkEVM架构: <a href="https://learnblockchain.cn/article/5487" target="_blank" rel="noopener noreferrer">https://learnblockchain.cn/article/5487</a></p><p>CSDN大佬Polygon解析系列：<a href="https://blog.csdn.net/mutourend/article/details/125971262" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/mutourend/article/details/125971262</a></p><p>zkNode: <a href="https://github.com/0xPolygonHermez/zkevm-node" target="_blank" rel="noopener noreferrer">https://github.com/0xPolygonHermez/zkevm-node</a></p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/note/zh-Hans/layer2/scroll_architecture"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Scroll整体架构和主要流程</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/note/zh-Hans/layer2/ethereum_storage"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">EthStorage</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#概述" class="table-of-contents__link toc-highlight">概述</a></li><li><a href="#polygon-zkevm整体架构" class="table-of-contents__link toc-highlight">Polygon zkEVM整体架构</a></li><li><a href="#zknode" class="table-of-contents__link toc-highlight">zkNode</a><ul><li><a href="#zknode架构" class="table-of-contents__link toc-highlight">zkNode架构</a></li><li><a href="#zknode中的角色" class="table-of-contents__link toc-highlight">zkNode中的角色</a></li><li><a href="#疑问" class="table-of-contents__link toc-highlight">疑问</a></li><li><a href="#交易流程" class="table-of-contents__link toc-highlight">交易流程</a></li><li><a href="#三种finality" class="table-of-contents__link toc-highlight">三种Finality</a></li></ul></li><li><a href="#跨链" class="table-of-contents__link toc-highlight">跨链</a><ul><li><a href="#l1---l2" class="table-of-contents__link toc-highlight">L1---&gt;L2</a></li></ul></li><li><a href="#poeproof-0f-efficiency" class="table-of-contents__link toc-highlight">POE(Proof-0f-Efficiency)</a></li><li><a href="#激励机制" class="table-of-contents__link toc-highlight">激励机制</a></li><li><a href="#疑问-1" class="table-of-contents__link toc-highlight">疑问：</a></li><li><a href="#参考" class="table-of-contents__link toc-highlight">参考</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 qymlyl note</div></div></div></footer></div>
<script src="/note/zh-Hans/assets/js/runtime~main.4c2e441e.js"></script>
<script src="/note/zh-Hans/assets/js/main.7f2867a2.js"></script>
</body>
</html>